<!DOCTYPE html>
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>WebGL</title>
<style>
  * {margin: 0; padding: 0;}
  canvas
  {
    width: 100vw;
    height: 100vh;
    display: block;
  }
</style>
</head>
<body>
<canvas id="mainCanvas"></canvas>
<script src="gl.js"></script>
<script src="dat.min.js"></script>
<script>
  var gl;
  window.addEventListener("load",async function()
  {
    //............................................        
    //Get our extended GL Context Object
    let mainCanvas = new GLInstance("mainCanvas");
    gl = mainCanvas.gl;

    //............................................
    // Load Shader Strings
    vShaderString = await fileShaderSrc('shader.vert');
    fShaderString = await fileShaderSrc('shader.frag');

    //............................................
    // Create Program from Shaders
    let program  = mainCanvas.createProgram(vShaderString,fShaderString,true);

    //............................................
    //Set Up Data Buffers
    let quadVertices =
    [   // X,Y Vert Positions     X,Y TexCoords
         -1.0, -1.0,              0.0, 1.0,
          1.0, -1.0,              1.0, 1.0,
          1.0, 1.0,               1.0, 0.0,
         -1.0, 1.0,               0.0, 0.0
    ];

    let quadIndices = [0, 1, 2, 2, 3, 0];

    // send the vertex & indices buffers to the GPU
    let vertexBufferObject = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBufferObject); 
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(quadVertices), gl.STATIC_DRAW);
    //gl.bindBuffer(gl.ARRAY_BUFFER, null);

    let indexBufferObject = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferObject);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(quadIndices), gl.STATIC_DRAW);
    //gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

    // tell the GPU how the buffer's structured and where to point its attribute variables
  let positionAttribLocation = gl.getAttribLocation(program, 'a_vertPosition');
  gl.vertexAttribPointer(
    positionAttribLocation, // Attribute location
    2, // number of elements per attribute
    gl.FLOAT, // type of elements
    gl.FALSE, // is data normalised?
    4 * Float32Array.BYTES_PER_ELEMENT, // size of an individual vertex
    0 // offset from the begining of a single vertex
  );
  gl.enableVertexAttribArray(positionAttribLocation);

  let texCoordAttribLocation = gl.getAttribLocation(program, 'a_texCoord');
  gl.vertexAttribPointer(
    texCoordAttribLocation, // Attribute location
    2, // number of elements per attribute
    gl.FLOAT, // type of elements
    gl.FALSE, // is data normalised?
    4 * Float32Array.BYTES_PER_ELEMENT, // size of an individual vertex
    2 * Float32Array.BYTES_PER_ELEMENT // offset from the begining of a single vertex
  );
  gl.enableVertexAttribArray(texCoordAttribLocation);

  // send texture to the GPU

  // Asynchronously load multiple images
   let imageURLs =[
     'noise-composition.png'];
  loadImages(imageURLs, (images) => 
   {
      // create textures
      var textures = [];
      for (var ii = 0; ii < imageURLs.length; ++ii)
      {
        let texture = gl.createTexture();
        
        gl.activeTexture(gl.TEXTURE0 + ii);
        gl.bindTexture(gl.TEXTURE_2D, texture);

        // Set the parameters so we can render any size image.
        // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

        // Upload the image into the texture.
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[ii]);
        gl.generateMipmap(gl.TEXTURE_2D);

        // add the texture to the array of textures.
        textures.push(texture); // Maybe needed when I have different programs running?
      }
    });

    //............................................
    //Set Up For Drawing
    gl.useProgram(program);        //Activate the Shader

    //Get Uniform Locations
    let uniformLocations = mainCanvas.get_uniform_locations_from_shader_string(program, fShaderString);

    // set which texture units to render with.
    gl.uniform1i(uniformLocations['u_texture'], 0);  // texture unit 0
    gl.uniform1i(uniformLocations['u_texture2'], 1);  // texture unit 1

    //Set Uniforms
    gl.uniform1f(uniformLocations["u_pointSize"], 1.0);
    gl.uniform2f(uniformLocations["u_resolution"], mainCanvas.canvas.width, mainCanvas.canvas.height);
    gl.uniform1f(uniformLocations["u_deltaTime"], 0.0);

    // DAT GUI STUFF
    guiControls = new function()
    {
      this.noise1_move_speed = 0.001;
      this.noise2_move_speed = 0.001;
      this.noise3_move_speed = 0.001;
      this.noise1_octave = 0.1;
      this.noise2_octave = 0.1;
      this.distortion_amount = 0.1;
      this.distortion_amount_2 = 0.1;
    }
    let datGUI = new dat.GUI();
    datGUI.add(guiControls, 'noise1_move_speed', 0, 4).setValue(1.0757);
    datGUI.add(guiControls, 'noise2_move_speed', 0, 4).setValue(3.3734);
    datGUI.add(guiControls, 'noise3_move_speed', 0, 4).setValue(4.0);
    datGUI.add(guiControls, 'noise1_octave', 0, 10).setValue(6.7);
    datGUI.add(guiControls, 'noise2_octave', 0, 10).setValue(5.0);
    datGUI.add(guiControls, 'distortion_amount', 0, 4).setValue(0.65);
    datGUI.add(guiControls, 'distortion_amount_2', 0, 4).setValue(0.19);
    // end: DAT GUI STUFF

    rloop = new RenderLoop(onRender).start();
    
    // MAIN RENDER LOOP
    let frameCount = 0.0;
    function onRender(dt)
    {
      frameCount += dt;
      // set uniforms live
      gl.uniform1f(uniformLocations["u_deltaTime"], frameCount);
      gl.uniform1f(uniformLocations["u_noise1_move_speed"], guiControls.noise1_move_speed);
      gl.uniform1f(uniformLocations["u_noise2_move_speed"], guiControls.noise2_move_speed);
      gl.uniform1f(uniformLocations["u_noise3_move_speed"], guiControls.noise3_move_speed);
      gl.uniform1f(uniformLocations["u_noise1_octave"], guiControls.noise1_octave);
      gl.uniform1f(uniformLocations["u_noise2_octave"], guiControls.noise2_octave);
      gl.uniform1f(uniformLocations["u_distortion_amount"], guiControls.distortion_amount);
      gl.uniform1f(uniformLocations["u_distortion_amount_2"], guiControls.distortion_amount_2);
      mainCanvas.clearCanvas();
      gl.drawElements(gl.TRIANGLES, quadIndices.length, gl.UNSIGNED_SHORT, 0); // draw type, number of vertices, type of data, offset
    }
  });
</script>
</body>
</html>
