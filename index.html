<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>WebGL</title>
<script id="vertex_shader" type="x-shader/x-vertex">#version 300 es
precision highp float;
in vec2 a_vertPosition;
uniform float u_pointSize;

void main()
{
  gl_PointSize = u_pointSize;
  gl_Position = vec4(a_vertPosition, 0.0, 1.0);
}
  </script>

  <script id="fragment_shader" type="x-shader/x-fragment">#version 300 es 
precision highp float; // high precision seems to fix snoise on some phones

uniform vec2 u_resolution;
uniform float u_deltaTime;

out vec4 outColour;

// Optimized Ashima Simplex noise2D by @makio64 https://www.shadertoy.com/view/4sdGD8
// Original shader : https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl
// snoise return a value between 0 & 1
// v5 fixed diagonal from abje comment
/*lowp*/ vec3 permute(in /*lowp*/ vec3 x) { return mod( x*x*34.+x, 289.); }
/*lowp*/ float snoise(in /*lowp*/ vec2 v) {
  /*lowp*/ vec2 i = floor((v.x+v.y)*.36602540378443 + v),
      x0 = (i.x+i.y)*.211324865405187 + v - i;
  /*lowp*/ float s = step(x0.x,x0.y);
  /*lowp*/ vec2 j = vec2(1.0-s,s),
      x1 = x0 - j + .211324865405187, 
      x3 = x0 - .577350269189626; 
  i = mod(i,289.);
  /*lowp*/ vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),
       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),
       x = fract(p * .024390243902439) * 2. - 1.,
       h = abs(x) - .5,
      a0 = x - floor(x + .5);
  return .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));
}

void main() {
  vec2 uv = gl_FragCoord.xy/u_resolution;
  vec2 st = uv;
  vec2 st2 = uv;

  // Create noise map

  float n = 0.0; // our noise variable

  st.y -= u_deltaTime * 0.5;
  st2.y -= u_deltaTime * 0.725;
  //st.x += sin(u_deltaTime/10.0) * 4.5; // wind simulation

  const float distortionAmount = 1.0;
  n = snoise(st * 4.3 + ((snoise(st2 * 5.0) - 0.5)) * distortionAmount); // modulate one noise by another changing at a different speed
  n *= 0.5; // compensate for the layering of noise

  // create gradient map

  float g = 0.0; // our gradient variable

  const float gradientHeightLimiter = 0.45;
  g = mix(1.3, 0.0, uv.y + gradientHeightLimiter);

  // add noise to gradient
  float ng = n + g;

  // display result

  vec3 colour = vec3(ng);
  //vec3 colour = vec3(smoothstep(0.0,1.0, pow(n,2.0)),smoothstep(0.0,1.0,pow(n,8.0)), 0.0);

  outColour = vec4(colour,1.0);
}
  </script>
  <style>
  * {margin: 0; padding: 0;}
  canvas
  {
    width: 100vw;
    height: 100vh;
    display: block;
  }
</style>
</head>
<body>
<canvas id="mainCanvas"></canvas>
<script src="gl.js"></script>
<script>
  var gl;
  window.addEventListener("load",function()
  {
    //............................................        
    //Get our extended GL Context Object
    let mainCanvas = new GLInstance("mainCanvas");
    gl = mainCanvas.gl;

    //............................................
    // Create Program from Shaders
    let program  = mainCanvas.createProgram("vertex_shader","fragment_shader",true);

    //............................................
    //Set Up Data Buffers
    let quadVertices = // X,Y positions
    [
      -1.0, -1.0,
      1.0, -1.0,
      1.0, 1.0,
      -1.0, 1.0,
    ];

    let quadIndices = [0, 1, 2, 2, 3, 0];

    // send the vertex & indices buffers to the GPU
    let vertexBufferObject = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBufferObject); 
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(quadVertices), gl.STATIC_DRAW);
    //gl.bindBuffer(gl.ARRAY_BUFFER, null);

    let indexBufferObject = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferObject);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(quadIndices), gl.STATIC_DRAW);
    //gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

    // tell the GPU how the buffer's structured and where to point its attribute variables
    let positionAttribLocation = gl.getAttribLocation(program, 'a_vertPosition');
    gl.vertexAttribPointer(
      positionAttribLocation, // Attribute location
      2, // number of elements per attribute
      gl.FLOAT, // type of elements
      gl.FALSE, // is data normalised?
      2 * Float32Array.BYTES_PER_ELEMENT, // size of an individual vertex
      0 // offset from the begining of a single vertex
    );
    gl.enableVertexAttribArray(positionAttribLocation);

    //............................................
    //Set Up For Drawing
    gl.useProgram(program);        //Activate the Shader

    //Get Uniform Locations
    let u_pointSizeUniformLocation = gl.getUniformLocation(program,"u_pointSize");
    let u_resolutionUniformLocation = gl.getUniformLocation(program, 'u_resolution');
    let u_deltaTimeUniformLocation = gl.getUniformLocation(program, 'u_deltaTime');

    //Set Uniforms
    gl.uniform1f(u_pointSizeUniformLocation, 1.0);
    gl.uniform2f(u_resolutionUniformLocation, mainCanvas.canvas.width, mainCanvas.canvas.height);
    gl.uniform1f(u_deltaTimeUniformLocation, 0.0);

    rloop = new RenderLoop(onRender).start();
    
    // MAIN RENDER LOOP
    let frameCount = 0.0;
    function onRender(dt)
    {
      frameCount += dt;
      gl.uniform1f(u_deltaTimeUniformLocation, frameCount);
      mainCanvas.clearCanvas();
      gl.drawElements(gl.TRIANGLES, quadIndices.length, gl.UNSIGNED_SHORT, 0); // draw type, number of vertices, type of data, offset
    }
  });
</script>
</body>
</html>
