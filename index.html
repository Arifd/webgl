<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>WebGL</title>
<script id="vertex_shader" type="x-shader/x-vertex">#version 300 es
precision highp float;
in vec2 a_vertPosition;
in vec2 a_texCoord;
uniform float u_pointSize;

out vec2 v_texCoord;

void main()
{
  gl_PointSize = u_pointSize;
  v_texCoord = a_texCoord;
  gl_Position = vec4(a_vertPosition, 0.0, 1.0);
}
  </script>

  <script id="fragment_shader" type="x-shader/x-fragment">#version 300 es 
precision highp float; // high precision seems to fix snoise on some phones

uniform vec2 u_resolution;
uniform float u_deltaTime;

in vec2 v_texCoord;
uniform sampler2D u_texture;

uniform float u_noise1_move_speed;// = 0.5;
uniform float u_noise2_move_speed;// = 0.725;
uniform float u_noise1_octave;// = 4.3;
uniform float u_noise2_octave;// = 5.0;
uniform float u_distortion_amount;// = 1.0;

out vec4 outColour;

// Optimized Ashima Simplex noise2D by @makio64 https://www.shadertoy.com/view/4sdGD8
// Original shader : https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl
// snoise return a value between 0 & 1
// v5 fixed diagonal from abje comment
/*lowp*/ vec3 permute(in /*lowp*/ vec3 x) { return mod( x*x*34.+x, 289.); }
/*lowp*/ float snoise(in /*lowp*/ vec2 v) {
  /*lowp*/ vec2 i = floor((v.x+v.y)*.36602540378443 + v),
      x0 = (i.x+i.y)*.211324865405187 + v - i;
  /*lowp*/ float s = step(x0.x,x0.y);
  /*lowp*/ vec2 j = vec2(1.0-s,s),
      x1 = x0 - j + .211324865405187, 
      x3 = x0 - .577350269189626; 
  i = mod(i,289.);
  /*lowp*/ vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),
       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),
       x = fract(p * .024390243902439) * 2. - 1.,
       h = abs(x) - .5,
      a0 = x - floor(x + .5);
  return .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));
}

  //  Function from IÃ±igo Quiles
//  www.iquilezles.org/www/articles/functions/functions.htm
float parabola( float x, float k ){
    return pow( 4.0*x*(1.0-x), k );
}

void main() {
  vec2 uv = gl_FragCoord.xy/u_resolution;
  vec2 st = uv;
  vec2 st2 = uv;

  // Create noise map

  float n = 0.0; // our noise variable

  st.y -= u_deltaTime * u_noise1_move_speed;
  st2.y -= u_deltaTime * u_noise2_move_speed;
  //st.x += sin(u_deltaTime/10.0) * 4.5; // wind simulation

  // modulate one noise by another changing at a different speed
  // snoise outputs 0 - 1, therefore we * 2.0 - 1.0 to balance 
  // n = snoise(st * u_noise1_octave + ((snoise(st2 * u_noise2_octave) * 2.0 - 1.0)) * u_distortion_amount);
  // n *= 0.5; // compensate for the layering of noise
  
  n = texture(u_texture, st + texture(u_texture, st2 * u_distortion_amount).r).b;

  // create gradient map

  float g = 0.0; // our gradient variable

  const float gradientHeightLimiter = 0.2;//0.45;
  g = mix(parabola(uv.x,0.285) * 0.8, 0.0, uv.y + gradientHeightLimiter);
  
  // add noise to gradient
  float ng = n + g;

  // display result

  vec3 colour = vec3(ng);
  //colour *= mix(vec3(1.0,1.0,0.0), vec3(1.0,0.0,0.0), uv.y);
  //colour *= vec3(1.0, // red
  //               clamp(smoothstep(0.0,1.0,ng),0.0,0.5),  // green
  //               0.0);                             // blue


  // outColour = vec4(vec3(texture(u_texture, v_texCoord).r), 1.0); // display textures
  // outColour = vec4(vec3(g),1.0);
  outColour = vec4(colour,1.0); 
}
  </script>
  <style>
  * {margin: 0; padding: 0;}
  canvas
  {
    width: 100vw;
    height: 100vh;
    display: block;
  }
</style>
</head>
<body>
<canvas id="mainCanvas"></canvas>
<script src="gl.js"></script>
<script src="dat.min.js"></script>
<script>
  var gl;
  window.addEventListener("load",function()
  {
    //............................................        
    //Get our extended GL Context Object
    let mainCanvas = new GLInstance("mainCanvas");
    gl = mainCanvas.gl;

    //............................................
    // Create Program from Shaders
    let program  = mainCanvas.createProgram("vertex_shader","fragment_shader",true);

    //............................................
    //Set Up Data Buffers
    let quadVertices =
    [   // X,Y Vert Positions     X,Y TexCoords
         -1.0, -1.0,              0.0, 1.0,
          1.0, -1.0,              1.0, 1.0,
          1.0, 1.0,               1.0, 0.0,
         -1.0, 1.0,               0.0, 0.0
    ];

    let quadIndices = [0, 1, 2, 2, 3, 0];

    // send the vertex & indices buffers to the GPU
    let vertexBufferObject = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBufferObject); 
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(quadVertices), gl.STATIC_DRAW);
    //gl.bindBuffer(gl.ARRAY_BUFFER, null);

    let indexBufferObject = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferObject);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(quadIndices), gl.STATIC_DRAW);
    //gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

    // tell the GPU how the buffer's structured and where to point its attribute variables
  let positionAttribLocation = gl.getAttribLocation(program, 'a_vertPosition');
  gl.vertexAttribPointer(
    positionAttribLocation, // Attribute location
    2, // number of elements per attribute
    gl.FLOAT, // type of elements
    gl.FALSE, // is data normalised?
    4 * Float32Array.BYTES_PER_ELEMENT, // size of an individual vertex
    0 // offset from the begining of a single vertex
  );
  gl.enableVertexAttribArray(positionAttribLocation);

  let texCoordAttribLocation = gl.getAttribLocation(program, 'a_texCoord');
  gl.vertexAttribPointer(
    texCoordAttribLocation, // Attribute location
    2, // number of elements per attribute
    gl.FLOAT, // type of elements
    gl.FALSE, // is data normalised?
    4 * Float32Array.BYTES_PER_ELEMENT, // size of an individual vertex
    2 * Float32Array.BYTES_PER_ELEMENT // offset from the begining of a single vertex
  );
  gl.enableVertexAttribArray(texCoordAttribLocation);

  // send texture to the GPU

  // Asynchronously load an image
  var image = new Image();
  image.src = "noisetex2.jpg";
  image.addEventListener('load', function()
  {
    // Now that the image has loaded copy it to the texture.
    let texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, image);
    gl.generateMipmap(gl.TEXTURE_2D);
    //gl.bindTexture(gl.TEXTURE_2D, null);
  });


    //............................................
    //Set Up For Drawing
    gl.useProgram(program);        //Activate the Shader

    //Get Uniform Locations
    let uniformLocations = mainCanvas.get_uniform_locations_from_shader_string(program, document.getElementById("fragment_shader").text);

    //Set Uniforms
    gl.uniform1f(uniformLocations["u_pointSize"], 1.0);
    gl.uniform2f(uniformLocations["u_resolution"], mainCanvas.canvas.width, mainCanvas.canvas.height);
    gl.uniform1f(uniformLocations["u_deltaTime"], 0.0);

    // DAT GUI STUFF
    guiControls = new function()
    {
      this.noise1_move_speed = 0.001;
      this.noise2_move_speed = 0.001;
      this.noise1_octave = 0.1;
      this.noise2_octave = 0.1;
      this.distortion_amount = 0.1;
    }
    let datGUI = new dat.GUI();
    datGUI.add(guiControls, 'noise1_move_speed', 0, 4).setValue(1.0757);
    datGUI.add(guiControls, 'noise2_move_speed', 0, 4).setValue(1.8561);
    datGUI.add(guiControls, 'noise1_octave', 0, 10).setValue(6.7);
    datGUI.add(guiControls, 'noise2_octave', 0, 10).setValue(5.0);
    datGUI.add(guiControls, 'distortion_amount', 0, 1).setValue(0.65);
    // end: DAT GUI STUFF

    rloop = new RenderLoop(onRender).start();
    
    // MAIN RENDER LOOP
    let frameCount = 0.0;
    function onRender(dt)
    {
      frameCount += dt;
      // set uniforms live
      gl.uniform1f(uniformLocations["u_deltaTime"], frameCount);
      gl.uniform1f(uniformLocations["u_noise1_move_speed"], guiControls.noise1_move_speed);
      gl.uniform1f(uniformLocations["u_noise2_move_speed"], guiControls.noise2_move_speed);
      gl.uniform1f(uniformLocations["u_noise1_octave"], guiControls.noise1_octave);
      gl.uniform1f(uniformLocations["u_noise2_octave"], guiControls.noise2_octave);
      gl.uniform1f(uniformLocations["u_distortion_amount"], guiControls.distortion_amount);
      mainCanvas.clearCanvas();
      gl.drawElements(gl.TRIANGLES, quadIndices.length, gl.UNSIGNED_SHORT, 0); // draw type, number of vertices, type of data, offset
    }
  });
</script>
</body>
</html>
